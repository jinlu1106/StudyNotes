# 抽象类 & 接口
## 抽象类（abstract Class）
+ 定义：拥有抽象方法的类即为抽象类（修饰符为abstract）。是从多个具体类中抽象出来的父类，具有更高层次的抽象。

    >“抽象方法”是只有声明而没有具体实现的方法，必须用abstract关键字来修饰。

+ 规则：
    + 因为抽象类中含有没有具体实现的方法，所以不能用抽象类创建对象。即使抽象类里面没有抽象方法，这个抽象类也不能创建实例。
    + 有抽象方法的类只能被定义为抽象类，抽象类里面可以没有抽象方法。
    + 抽象类里面可以包含成员变量、方法（普通方法/抽象方法）、构造器、初始化块、内部类5种成分，**抽象类的构造器不能用于创建实例，主要用于被其子类调用。**
    + 含有抽象方法的类（包括直接定义了一个抽象方法；或者继承了一个抽象类但没有完全实现父类包含的抽象方法；或者实现了一个接口但没有完全实现接口包含的抽象方法三种情况）只能被定义为抽象类。
+ abstract、final、static：
  + abstract：
    + abstract 修饰类时，表明这个类只能被继承；
    + abstract 修饰方法时，表明这个方法必须由子类提供实现（重写）；
    + abstract 不能修饰成员变量，也不能修饰局部变量，即没有抽象变量和抽象成员变量之说；
    + private 和 abstract 不能同时修饰方法。
  + final：
    + final 修饰的类不能继承；
    + final 修饰的方法不能被重写；
    + final 和 abstract 永远不能同时使用
  + static：
    + static 修饰一个方法时，表明这个方法属于类本身，即通过类就可以调用该方法，如果该方法为抽象方法，则通过类调用该方法时会出现错误。

## 接口（interface）
#### Java8 改进的接口
+ 定义：接口是从多个相似类里面抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现分离的设计哲学。
+ 规则：
  + 接口里面可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法和默认方法）、内部类。
  + 在接口中定义成员变量时，不管是否使用`public static final`修饰符，接口里面的成员变量总是使用这三个修饰符来修饰。而且接口里面没有构造器和初始化块，所以只能在定义时指定默认值。
  + 在接口中定义普通方法时，不管是否使用`public abstract`修饰符，接口里面的普通方法总是使用这两个修饰符来修饰。
  + 类方法（static）和默认方法（default）必须有方法实现。这两个方法默认使用`public`修饰。
  + 接口支持完全多继承，一个接口可以有多个直接父接口
  + 接口不能用于创建实例，但接口可以用于声明引用类型变量，然后被其实现类实现。
+ 可以把实现接口理解为一种特殊的继承，相当于实现类彻底继承了一个抽象类。
+ 当一个类实现多个接口时，如果接口里面存在两个或者两个以上的方法签名相同的默认方法时，这时被认为是冲突的，解决冲突需要遵守以下几个原则：

  （1）类或父类中显示声明的方法，他的优先级高于所有的默认方法；

  （2）如果规则（1）失效，则选择与当前类距离最近的具有具体实现的默认方法；

  （3）如果规则（2）也失效，则需要显示指定接口。

  故编译会报错，正常情况下次序是` 类 ——> 接口 `方法

#### Java9 改进的接口
+ Java9 关于接口的新特性

  **interface Private Method（接口私有方法）**

  该特性完全是为了 Java8 中的 default 和 static 方法服务的。如果接口中有几个默认方法代码几乎相同，通常需要重构这些方法，调用一个可复用的私有方法，但默认方法不能是私有的，所以将复用代码建为一个默认方法不是一个解决方案，因为该辅助方案会成为公共API的一部分。为解决这个方案，Java9允许向接口提供私有方法来解决这个问题。
  ```Java
  public interface MyInterface {
    void normalInterfaceMethod();

    default void InterfaceMethodWithDefault() {
        init();
    }

    default void anotherDefaultMethod() {
        init();
    }

    //java9新特性：interface private Method
    private void init() {
        System.out.println("init");
    }
  }
  ```

## 接口和抽象类
#### 相似点：
  + 接口和抽象类都不能被实例化，他们都位于继承树的顶端，用于被其他类实现和继承。
  + 接口和抽象类都可以包含抽象类，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

#### 不同点：
  + 设计目的：
    + **接口** 体现的是一种规范，是多个模块间的耦合标准。一个系统中的接口不应该经常改变，一旦改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都要重新改写。
    + **抽象类** 作为系统中的多个子类的共同父类，他所体现的是一种`模板式设计`。
  + 接口里面只能定义静态常量，不能定义普通成员变量。抽象类既可以定义普通成员变量也可以定义静态常量。
  + 接口里面不包含构造器，抽象类里面可以包含构造器，抽象类里的构造器不是用于创建对象，而是让其子类调用来完成抽象类的初始化操作。
  + 接口里面不能包含初始化块，但抽象类完全可以包含初始化块。
  + 抽象类是单继承，接口可以实现多继承。

#### Java 8 之后为什么有了接口还要使用抽象类？
答：（1）在 Java 8 的接口中，即使有了 default method ，也暂时无法完全取代抽象类。

  （2）接口中没有 this ，没有构造函数，不能拥有实例变量或者实例方法，无法保存状态，而抽象方法可以。

  （3）接口不能拥有非静态成员变量。Java 8 中接口只能提供静态常量、公有方法声明、公有默认方法和类方法；而 Java 9 新特性中允许接口中拥有私有方法。默认方法最初的设计目的是让已经存在的接口可以演化——添加新方法时不需要原本已经实现该接口的类做任何改变（甚至不需要重新编译）就可以直接使用新版本的接口，但是这已经在很大程度上覆盖了抽象类的特性。未来的 Java 版本的接口可能会有更强大的功能，或许能更大程度的替代原本需要抽象类的场景。
