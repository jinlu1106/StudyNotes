# 工厂模式
[参考博客1](http://blog.csdn.net/zhengzhb/article/details/7348707)

[参考博客2](http://blog.csdn.net/jason0539/article/details/23020989)

+ 工厂模式主要是为创建对象提供过渡接口，以便创建对象的具体过程屏蔽隔离起来。
+ 在需要生成复杂对象的时候需要使用工厂模式，如果是可以直接通过new来直接创建的对象则不需要使用。
+ 工厂模式根据抽象程度分为不同的三种：
简单工厂模式（Simple Factory）---工厂方法模式（Factory Method）---抽象工厂模式（Abstract Factory）

### 简单工厂模式（Simple Factory）
+ 定义：建立一个工厂（一个函数或者类方法）来制造新的对象。
+ 组成：
  + 工厂类：这是简单工厂模式的核心，用来创建产品
  + 抽象产品：一般为具体产品继承的父类或者实现的接口
  + 具体产品：所要创建的实例的实现类
+ 代码：

  假定要制造汽车，客户有不同的需求，有的可能想要BMW320型，有的可能需要BMW523

  产品类：
  ```Java
  //抽象产品
  abstract class BMW {
      public BMW(){

      }
  }
  //具体产品BMW320
  public class BMW320 extends BMW {
      public BMW320(){
          System.out.println("制造-->BMW320");
      }
  }
  //具体产品BMW523
  public class BMW523 extends BMW {
      public BMW523(){
          System.out.println("制造-->BMW523");
      }
  }

  ```
  工厂类：
  ```Java
  //工厂类
  public class Factory {
      public BMW createBMW(int type){
          switch (type){
              case 320:
                  return new BMW320();
              case 523:
                  return new BMW523();
              default:break;
          }
          return null;
      }
  }
  ```
  客户类：
  ```Java
  //客户类
  public class Customer {
      public static void main(String[] args) {
          Factory factory = new Factory();
          factory.createBMW(320);
          factory.createBMW(523);
      }
  }
  ```
  **从开闭原则上分析简单工厂模式：**

  + 当客户不满足现有车型时，想要一种更好的车型，只要这种车符合抽象产品制定的合同，那么只需要通知工厂类就可以被客户使用了。`所以对产品来说是符合开闭原则的。`
  + 但是对于工厂来说，每增加一种新的车型，都要在工厂类里面创建相应的业务逻辑。`所以对于工厂类是违背开闭原则的。`

### 工厂方法模式（Factory Method）
+ 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。
+ 组成：
  + 工厂接口：工厂接口是工厂方法模式的核心，与调用者直接交互产品来提供产品。在实际编程中，有时也会使用一个抽象类来作为与调用者交互的接口，其本质是一样的。
  + 工厂实现：在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。
  + 产品接口：产品接口的主要目的是为了定义产品实现的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口也可以通过抽象类来代替，但是要注意不要违背里氏替换原则。
  + 产品实现：实现产品接口的具体类。
+ 代码：

  产品接口及产品实现：
  ```Java
  //产品接口
  public interface IProduct {
      void create();
      void show();
  }
  //产品实现1
  public class Product1 implements IProduct {
       @Override
       public void create() {
           System.out.println("Create Product1");
       }

       @Override
       public void show() {
           System.out.println("Show Product1");
       }
  }
  //产品实现2
  public class Product2 implements IProduct{
      @Override
      public void create() {
          System.out.println("Create Product2");
      }

      @Override
      public void show() {
          System.out.println("Show Product2");
      }
  }
  ```
  工厂接口及工厂实现：
  ```Java
  //工厂接口
  public interface IFactory {
      public List<IProduct> createProduct();
  }
  //工厂实现
  public class FactoryMethod implements IFactory {
      @Override
      public List<IProduct> createProduct() {
          List <IProduct> list = new ArrayList<>();
          IProduct iProduct = new Product1();
          IProduct iProduct1 = new Product2();
          list.add(iProduct);
          list.add(iProduct1);
          return list;
      }
  }
  ```
  客户类：
  ```Java
  //客户类
  public class Client {
      public static void main(String[] args) {
          FactoryMethod factoryMethod = new FactoryMethod();
          List<IProduct> product = factoryMethod.createProduct();
          for (IProduct p:
               product) {
              p.create();
              p.show();
          }
      }
  }
  ```
  运行结果：
  ```
  Create Product1
  Show Product1
  Create Product2
  Show Product2
  ```

### 抽象工厂模式（abstract Factory）
[参考博客](http://blog.csdn.net/zhengzhb/article/details/7359385)

+ 定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
+ 组成：与工厂方法模式类似。
+ **抽象工厂与工厂方法模式的区别：** 抽象工厂是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于 ，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类。也就是说，工厂方法模式提供的所有产品都衍生自一个接口或者抽象类，而抽象工厂所提供的产品则是衍生自不同的接口或者抽象类。
+ 代码：
  产品接口及产品实现
  ```Java
  //style1产品接口
  public interface IProduct1 {
      public void show();
  }
  //style2产品接口
  public interface IProduct2 {
      public void show();
  }
  //style1产品实现类
  public class Product1 implements IProduct1 {
      @Override
      public void show() {
          System.out.println("create style1 product");
      }
  }
  //style2产品接口
  public class Product2 implements IProduct2 {
      @Override
      public void show() {
          System.out.println("create style2 product");
      }
  }
  ```
  工厂接口及工厂实现：
  ```Java
  //抽象工厂
  public interface IFactory {
      public IProduct1 createProduct1();
      public IProduct2 createProduct2();
  }
  //工厂实现
  public class Factory implements IFactory {
      @Override
      public IProduct1 createProduct1() {
          return new Product1();
      }

      @Override
      public IProduct2 createProduct2() {
          return new Product2();
      }
  }
  ```
  客户端
  ```Java
  //客户类
  public class Client {
      public static void main(String[] args) {
          Factory factory = new Factory();
          factory.createProduct1().show();
          factory.createProduct2().show();
      }
  }
  ```
  运行结果：
  ```
  create style1 product
  create style2 product
  ```

## 总结：
  无论是简单工厂模式，工厂方法模式还是抽象工厂模式，他们在形式和特点上都是极为相似的
